# Мутиращи член-данни. Разделна компилация. Композиция и агрегация. Копиращ конструктор и оператор за присвоявяне (=). Голяма четворка

## Мутиращи член-данни (Mutable)
Спецификаторът mutable е приложен само в С++. Той позволява на член на обект да предефинира константността. Така mutable член на const обект не е const и може да бъде изменян.

```c++
struct Test
{
private:
   mutable int n;
public:
   void f() const
   {
   	n++;
   }

};

int main()
{
   const Test t;

   t.f();
}
```

**Използваме го само в крайни случаи!**

## Разделна компилация.

Една програма на С++ може да бъде разбита в множество изходни файлове(.cpp), които се **компилират независимо един от друг**, т.е. осъществява се **разделна компилация**. <br />
Преди самата компилация изходният файл бива подаден на препроцесора, който изпълнява всички директиви (започващи с #). <br />
Пример: при всяко срещане на #include препроцесорът го заменя със съответстващото му парче код (хедър файл, съдържащ декларации). <br />
В резултат на компилацията се получават няколко **обектни файла** (файлове с разширение **.obj**), те представляват машинен код. <br />
Изпълнимият код на програмата (файл с разширение .ехе) се получава след свързване на обектните файлове от linker-a (**Linking**). <br />
Той асоциира всички референции към имена (на променливи, функции, класове и т.н.) на един обектов файл към съответните им дефиниции, които могат да се намират и в други изходни файлове. <br />
Понякога се случва дефинициите да не се намират в никой от обектните файлове, като в този случай компилаторът претърсва стандартната C++ библиотека (libcp.lib), стандартната C библиотека (libc.lib), а също и всяка ръчно указана такава от програмиста. Ако такава дефиниция не бъде открита линкерът дава грешка. <br />
За да се възползваме максимално от разделната компилация, разделяме класовете на **.h** и **.cpp** файлове. <br />
Навсякъде където ще работим с класа, ще включваме **само .h файла.** По този начин, ако променим реализацията на някоя от функциите на класа, ще се **прекомпилира само този файл**. <br />

![enter image description here](https://i.ibb.co/N9RnMHv/sss.png)

Проект на C/C++ е нещо, което се използва за генериране на един от тези три артефакта:
- Статична библиотека (.lib, .a)
- Динамична библиотека (.dll, .so)
- Изпълнима програма (.exe)
Естеството на генерирания артефакт няма голямо значение, но идеята за проект е все пак важна, защото ни казва какво трябва да бъде групирано в единица за анализ.(Analysis Unit). <br />

За съжаление, няма една стандартизирана система за изграждане или един формат на проект за C++, а много различни системи (autoconf, cmake, makefiles, vcxproj, xcodeproj…). <br />
Всяка от тези системи е много конфигурируема, което прави автоматичното извличане на информация в тези проекти много трудна задача. Така че трябва да разберете по-добре какво прави даден проект, преди да можете да конфигурирате анализ. <br />

Процесът на изграждане на проекта се основава на следните стъпки:
- Source code preprocessing(предварителна обработка на изходния код): Всеки файл с изходен код (.c, .cpp, .cxx, .cc…) се обработва, за да включва допълнителни редове код, идващи от други файлове (обикновено заглавни файлове: .h, .hh, .hpp, .tpp , .inl) и за генериране на пълния изходен код, известен още като предварително обработения изходен файл. Имайте предвид, че заглавен файл може да бъде включен в други заглавни файлове.
- Compilation(компилация): Всеки предварително обработен изходен файл се компилира в обектен файл (.o, .obj).
- Link-edition(издание на връзка): Всички съответни обектни файлове са свързани заедно, за да се получи крайният артефакт.

- **#pragma once** - директива, която казва на компилатора как да компилира даден код. Конкретно за once - казва на компилатора, че този header файл трябва да се обработи само веднъж;
- **header guard-ове** - първия път като минем през този хедър за пръв път да се дефинира съответното съдържание. Чрез #define избираме уникален идентификатор, затова му се дава името на файла (евентуално с директорията, в която се намира), например library.h именуваме като LIBRARY_H. Съответно, преди #define проверяваме - дефиниран ли е съответния индикатор, т.е. #if !defined(LIBRARY_H), което е еквивалентно на #ifndef LIBRARY_H. Съответно, ако индикаторът не е бил дефиниран - влизаме в иф-а, след което го дефинираме и изпълняваме съответния код до #endif-a. Синтаксис:

```c++
#ifndef LIBRARY_H
#define LIBRARY_H

//DO SOMETHING
	
#endif
```

## Композиция и агреграция
### Композция
```c++
class A {};

class B {};

class X 
{
	A obj1;
	B obj2;
};
```
Жизненият цикъл на obj1 и obj2 се контролира от класа Х. </br>
X притежава A и B.

![My Image](https://drive.google.com/thumbnail?id=16cxP8_85NY8DXFEmtIHNAnMK3nPw7AyK)


### Агрегация
```c++
class A {};

class B {};

class X 
{
	A* ptr;
};

class Y
{
    B& ref;
};
 ```
 
X и Y не отговорят за жизнените цикли съответно на А и В.

X използва A, Y използва B.

![My Image](https://drive.google.com/thumbnail?id=1t8glSdNTQI6AbSIDrHLXKcyPgrD_76BA)


## Копиращ конструктор и оператор =
Заедно с конструктора по подразбиране и деструктора във всеки клас се дефинират и следните член-функции:
 - Копиращ конструктор - конструктор, който приема обект от същия клас и създава новият обект като негово копие.
 - Оператор= - функция/оператор, който приема  обект от същия клас и променя данните на съществуващ обект от същия клас (обектът от който извикваме функцията).

**При липсата на дефиниран/и копиращ конструктор и/или оператор=, компилаторът автоматично създава такива по подразбиране.**
**Забележка:** Копиращият конструктор създава нов обект, а оператор= модифицира вече съществуващ такъв!

```c++
#include <iostream>

struct Test {
    Test() {
        std::cout << "Default constructor\n";
    }

    Test(const Test& other) {
        std::cout << "Copy constructor\n";
    }

    Test& operator=(const Test& other) {
        std::cout << "operator=\n";
	    return *this;
    }

    ~Test() {
        std::cout << "Destructor\n";
    }
};

void f(Test object) {
    //do Stuff
}

void g(Test& object) {
    //do Stuff
}

int main()
{
    Test t;      //Default constructor;

    Test t2(t);  // Copy constructor
    Test t3(t2); // Copy constructor	
    t2 = t3;     // operator=
    t3 = t;      // operator=

    Test newTest = t; //Copy constructor !!!!!!!

    f(t);   // Copy constructor	
    g(t);   // nothing. We are passing it as a reference. We are not copying it!

    Test* ptr = new Test();  // Default constructor // we create a new object in the dynamic memory. The destructor must be invoked explicitly  (with delete)

    delete ptr; // Destructor	

} //Destructor Destructor Destructor Destructor
```

## Голяма четворка
- Конструктор по подразбиране (default constructor)
- Копиращ конструктор
- Оператор=
- Деструктор

**Разписваме Г4 само, когато имаме динамична памет в класа/ структурата!**


## **Задачи**

**Задача 1:** Да се напише клас студент с име (с произволна дължина), масив от оценки (с произволна дължина) и цитат (с максимална дължина 30 символа).

**Задача 2:** Да се реализира клас KBaseNumber, който да служи за работа с числа в k-ична бройна система. Всяко число се представя като символен низ с произволна дължина. Класът да поддържа следните функционалности:
- Конвертиране на числото в друга бройна система
- Сравняване с друго число
- Промяна на числото и основата на бройната система
- Принтиране на числото по подходящ начин
- Четене и записване в двоичен файл

Пример:

```c++
KBaseNumber num1("CE9A", 16);
num1.print(); // CE9A(16)
num1.saveToFile("file.bin");

KBaseNumber num2 = num1.convertTo(8);
num2.print(); // 147232(8)

std::cout<<num1.compareWith(num2)<<std::endl; // 0

num2.update("1312", 4);
std::cout<<num2.compareWith(num1)<<std::endl; // -1, защото num2=118(10), num1=52890(10) num2<num1

KBaseNumber num3;
num3.readFromFile("file.bin");
num3.print(); // CE9A(16)
```
